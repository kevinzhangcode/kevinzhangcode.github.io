[{"categories":["documentation"],"content":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","date":"2022-03-03","objectID":"/paper01/","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/"},{"categories":["documentation"],"content":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition 论文解读。 ","date":"2022-03-03","objectID":"/paper01/:0:0","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#"},{"categories":["documentation"],"content":"题目 Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition [ACL 2021 Long] [Code] ","date":"2022-03-03","objectID":"/paper01/:0:1","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#题目"},{"categories":["documentation"],"content":"摘要 众包被认为是有效监督学习的一个前瞻性解决方案，旨在通过群体劳动建立大规模的注释训练数据。以前的研究集中在减少众包注解的噪音对监督模式的影响。在这项工作中，我们采取了不同的观点，将所有众包注释重新视为与个别数据标注师有关的黄金标准。通过这种方式，我们发现众包可以与领域适应性（domain adaptation）高度相似，那么最近的跨领域方法的进展几乎可以直接应用于众包。在这里，我们以命名实体识别（NER）为研究案例，提出了一个Annotator-aware的表示学习模型，该模型受到领域适应方法的启发，试图捕捉有效的Domain-aware的特征。我们研究了无监督和有监督的众包学习，假设没有或只有小规模的专家注释可用，在一个基准的众包NER数据集上的实验结果表明，我们的方法是非常有效的，表现了一个新的最先进的性能。此外，在有监督的情况下，我们只需要很小规模的专家注释就可以获得令人印象深刻的性能提升。 ","date":"2022-03-03","objectID":"/paper01/:0:2","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#摘要"},{"categories":["documentation"],"content":"贡献 对众包学习提出了不同的看法，并建议将众包学习转化为领域适应问题（domain adaptation），这自然而然地将NLP的两个重要主题联系起来。 提出了一种新型的众包学习方法。尽管该方法在领域适应方面的新颖性有限，但它是第一项关于众包学习的工作，并能在NER上取得最先进的性能。 首次引入了有监督的众包学习，这是从领域适应性中借来的，将是NLP任务的一个前瞻性解决方案。 ","date":"2022-03-03","objectID":"/paper01/:0:3","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#贡献"},{"categories":["documentation"],"content":"模型架构 包括四个部分： (1) word representation (2) annotator switcher (3) BiLSTM Encoding (4) CRF inference and training. Fig-1.模型结构 词表示层（word representation） 假设存在一个包含$n$个单词的句子$w_1 \\dots w_n$,我们首先通过$\\texttt{Adapter} \\circ \\texttt{BERT}$将其转换为矢量表征. $$ e_1 \\dots e_n = \\texttt{Adapter} \\circ \\texttt{BERT}(w_1 \\dots w_n) $$ 注意：值得注意的是，$\\texttt{Adapter} \\circ \\texttt{BERT}$方法不再需要对庞大的BERT参数进行微调，而是通过调整轻得多的适配器参数来获得相当的性能。因此通过这种方式，可以很容易地将词的表示法扩展为annotator-aware的表示法。 注释者切换器层（annotator switcher） 作者目标是有效地学习不同数据标注师意识到的词汇特征，这可以被视为对个别注释者的上下文理解。因此，引入了一个注释者切换器，以支持带有注释者输入的$\\texttt{Adapter} \\circ \\texttt{BERT}$，其灵感来自于Parameter Generation Network (PGN)，其关键思想是使用参数生成网络（PGN），通过输入annotators动态地产生适配器参数。通过这种方式，模型可以在不同的annotators之间灵活地切换。 具体来说，假设$V$是所有适配器参数的矢量形式，通过打包操作，也可以解包恢复所有的适配器参数，PGN模块就是根据annotators的输入动态生成$\\texttt{Adapter} \\circ \\texttt{BERT}$的$V$，如模型图中右边的橙色部分所示，切换器switcher可以被形式化为： $$ \\begin{align} \\textbf{x} \u0026=\\textbf{r}_1’ \\dots \\textbf{n}_1’\\\\ \u0026=\\textbf{PGN} \\circ \\textbf{Adapter} \\circ \\textbf{BERT}(x,a)\\\\ \u0026=\\textbf{Adapter} \\circ \\textbf{BERT}(x,\\textbf{V}=\\mathbf{\\Theta} \\times \\textbf{e}^a) \\end{align} $$ 其中$\\mathbf{\\Theta} \\in \\mathcal{R}^{\\vert \\textbf{V} \\vert \\times\\textbf{e}^a}$，$\\textbf{x} =\\textbf{r}_1’ \\dots \\textbf{n}_1’$是注释者$a$对$x=w_1 \\dots w_n$的annotator-aware的表示，$\\textbf{e}^a$是annotator的embedding。 BiLSTM编码层（BiLSTM Encoding） $\\texttt{Adapter} \\circ \\texttt{BERT}$需要一个额外的面向任务的模块来进行高级特征提取。在这里利用单一的BiLSTM层来实现：$h_1 \\dots h_n = \\texttt{BiLSTM}(x)$，用于下一步的推理和训练。 CRF层（CRF inference and training） 最后使用CRF来计算候选顺序输出$y = l_1 \\dots l_n$的全局得分。 $$ \\begin{align} {\\textbf{o}_i} \u0026=\\textbf{W}^{crf} {\\textbf{h}_i}+\\textbf{b}^{crf} \\ \\end{align} $$ $$ \\begin{align} {\\sum_{i=1}^n} (\\textbf{T}[l_{i-1},l_i]+{\\textbf{o}_i}[l_i]) \\end{align} $$ 其中$\\textbf{W}^{crf}、 \\textbf{b}^{crf}、 \\textbf{T}$是模型的参数。给定一个输入$(x，a)$，通过维特比算法进行推理,对于训练，定义了一个句子级别的交叉熵目标。 $$ \\begin{align} p(y^a \\vert x,a) \u0026=\\frac{\\exp{\\texttt{score}(y^a \\vert x,a)}}{\\sum_y \\exp{\\texttt{score}(y \\vert x,a)}}\\\\ \\mathcal{L} \u0026=-\\log{(y^a \\vert x,a)} \\end{align} $$ 其中$y^a$是$a$对$x$的黄金标准输出，$y$属于所有可能的候选人，$p(y^a|x, a)$表示句子级的概率。 ","date":"2022-03-03","objectID":"/paper01/:0:4","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#模型架构"},{"categories":["documentation"],"content":"模型架构 包括四个部分： (1) word representation (2) annotator switcher (3) BiLSTM Encoding (4) CRF inference and training. Fig-1.模型结构 词表示层（word representation） 假设存在一个包含$n$个单词的句子$w_1 \\dots w_n$,我们首先通过$\\texttt{Adapter} \\circ \\texttt{BERT}$将其转换为矢量表征. $$ e_1 \\dots e_n = \\texttt{Adapter} \\circ \\texttt{BERT}(w_1 \\dots w_n) $$ 注意：值得注意的是，$\\texttt{Adapter} \\circ \\texttt{BERT}$方法不再需要对庞大的BERT参数进行微调，而是通过调整轻得多的适配器参数来获得相当的性能。因此通过这种方式，可以很容易地将词的表示法扩展为annotator-aware的表示法。 注释者切换器层（annotator switcher） 作者目标是有效地学习不同数据标注师意识到的词汇特征，这可以被视为对个别注释者的上下文理解。因此，引入了一个注释者切换器，以支持带有注释者输入的$\\texttt{Adapter} \\circ \\texttt{BERT}$，其灵感来自于Parameter Generation Network (PGN)，其关键思想是使用参数生成网络（PGN），通过输入annotators动态地产生适配器参数。通过这种方式，模型可以在不同的annotators之间灵活地切换。 具体来说，假设$V$是所有适配器参数的矢量形式，通过打包操作，也可以解包恢复所有的适配器参数，PGN模块就是根据annotators的输入动态生成$\\texttt{Adapter} \\circ \\texttt{BERT}$的$V$，如模型图中右边的橙色部分所示，切换器switcher可以被形式化为： $$ \\begin{align} \\textbf{x} \u0026=\\textbf{r}_1’ \\dots \\textbf{n}_1’\\\\ \u0026=\\textbf{PGN} \\circ \\textbf{Adapter} \\circ \\textbf{BERT}(x,a)\\\\ \u0026=\\textbf{Adapter} \\circ \\textbf{BERT}(x,\\textbf{V}=\\mathbf{\\Theta} \\times \\textbf{e}^a) \\end{align} $$ 其中$\\mathbf{\\Theta} \\in \\mathcal{R}^{\\vert \\textbf{V} \\vert \\times\\textbf{e}^a}$，$\\textbf{x} =\\textbf{r}_1’ \\dots \\textbf{n}_1’$是注释者$a$对$x=w_1 \\dots w_n$的annotator-aware的表示，$\\textbf{e}^a$是annotator的embedding。 BiLSTM编码层（BiLSTM Encoding） $\\texttt{Adapter} \\circ \\texttt{BERT}$需要一个额外的面向任务的模块来进行高级特征提取。在这里利用单一的BiLSTM层来实现：$h_1 \\dots h_n = \\texttt{BiLSTM}(x)$，用于下一步的推理和训练。 CRF层（CRF inference and training） 最后使用CRF来计算候选顺序输出$y = l_1 \\dots l_n$的全局得分。 $$ \\begin{align} {\\textbf{o}_i} \u0026=\\textbf{W}^{crf} {\\textbf{h}_i}+\\textbf{b}^{crf} \\ \\end{align} $$ $$ \\begin{align} {\\sum_{i=1}^n} (\\textbf{T}[l_{i-1},l_i]+{\\textbf{o}_i}[l_i]) \\end{align} $$ 其中$\\textbf{W}^{crf}、 \\textbf{b}^{crf}、 \\textbf{T}$是模型的参数。给定一个输入$(x，a)$，通过维特比算法进行推理,对于训练，定义了一个句子级别的交叉熵目标。 $$ \\begin{align} p(y^a \\vert x,a) \u0026=\\frac{\\exp{\\texttt{score}(y^a \\vert x,a)}}{\\sum_y \\exp{\\texttt{score}(y \\vert x,a)}}\\\\ \\mathcal{L} \u0026=-\\log{(y^a \\vert x,a)} \\end{align} $$ 其中$y^a$是$a$对$x$的黄金标准输出，$y$属于所有可能的候选人，$p(y^a|x, a)$表示句子级的概率。 ","date":"2022-03-03","objectID":"/paper01/:0:4","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#词表示层word-representation"},{"categories":["documentation"],"content":"模型架构 包括四个部分： (1) word representation (2) annotator switcher (3) BiLSTM Encoding (4) CRF inference and training. Fig-1.模型结构 词表示层（word representation） 假设存在一个包含$n$个单词的句子$w_1 \\dots w_n$,我们首先通过$\\texttt{Adapter} \\circ \\texttt{BERT}$将其转换为矢量表征. $$ e_1 \\dots e_n = \\texttt{Adapter} \\circ \\texttt{BERT}(w_1 \\dots w_n) $$ 注意：值得注意的是，$\\texttt{Adapter} \\circ \\texttt{BERT}$方法不再需要对庞大的BERT参数进行微调，而是通过调整轻得多的适配器参数来获得相当的性能。因此通过这种方式，可以很容易地将词的表示法扩展为annotator-aware的表示法。 注释者切换器层（annotator switcher） 作者目标是有效地学习不同数据标注师意识到的词汇特征，这可以被视为对个别注释者的上下文理解。因此，引入了一个注释者切换器，以支持带有注释者输入的$\\texttt{Adapter} \\circ \\texttt{BERT}$，其灵感来自于Parameter Generation Network (PGN)，其关键思想是使用参数生成网络（PGN），通过输入annotators动态地产生适配器参数。通过这种方式，模型可以在不同的annotators之间灵活地切换。 具体来说，假设$V$是所有适配器参数的矢量形式，通过打包操作，也可以解包恢复所有的适配器参数，PGN模块就是根据annotators的输入动态生成$\\texttt{Adapter} \\circ \\texttt{BERT}$的$V$，如模型图中右边的橙色部分所示，切换器switcher可以被形式化为： $$ \\begin{align} \\textbf{x} \u0026=\\textbf{r}_1’ \\dots \\textbf{n}_1’\\\\ \u0026=\\textbf{PGN} \\circ \\textbf{Adapter} \\circ \\textbf{BERT}(x,a)\\\\ \u0026=\\textbf{Adapter} \\circ \\textbf{BERT}(x,\\textbf{V}=\\mathbf{\\Theta} \\times \\textbf{e}^a) \\end{align} $$ 其中$\\mathbf{\\Theta} \\in \\mathcal{R}^{\\vert \\textbf{V} \\vert \\times\\textbf{e}^a}$，$\\textbf{x} =\\textbf{r}_1’ \\dots \\textbf{n}_1’$是注释者$a$对$x=w_1 \\dots w_n$的annotator-aware的表示，$\\textbf{e}^a$是annotator的embedding。 BiLSTM编码层（BiLSTM Encoding） $\\texttt{Adapter} \\circ \\texttt{BERT}$需要一个额外的面向任务的模块来进行高级特征提取。在这里利用单一的BiLSTM层来实现：$h_1 \\dots h_n = \\texttt{BiLSTM}(x)$，用于下一步的推理和训练。 CRF层（CRF inference and training） 最后使用CRF来计算候选顺序输出$y = l_1 \\dots l_n$的全局得分。 $$ \\begin{align} {\\textbf{o}_i} \u0026=\\textbf{W}^{crf} {\\textbf{h}_i}+\\textbf{b}^{crf} \\ \\end{align} $$ $$ \\begin{align} {\\sum_{i=1}^n} (\\textbf{T}[l_{i-1},l_i]+{\\textbf{o}_i}[l_i]) \\end{align} $$ 其中$\\textbf{W}^{crf}、 \\textbf{b}^{crf}、 \\textbf{T}$是模型的参数。给定一个输入$(x，a)$，通过维特比算法进行推理,对于训练，定义了一个句子级别的交叉熵目标。 $$ \\begin{align} p(y^a \\vert x,a) \u0026=\\frac{\\exp{\\texttt{score}(y^a \\vert x,a)}}{\\sum_y \\exp{\\texttt{score}(y \\vert x,a)}}\\\\ \\mathcal{L} \u0026=-\\log{(y^a \\vert x,a)} \\end{align} $$ 其中$y^a$是$a$对$x$的黄金标准输出，$y$属于所有可能的候选人，$p(y^a|x, a)$表示句子级的概率。 ","date":"2022-03-03","objectID":"/paper01/:0:4","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#注释者切换器层annotator-switcher"},{"categories":["documentation"],"content":"模型架构 包括四个部分： (1) word representation (2) annotator switcher (3) BiLSTM Encoding (4) CRF inference and training. Fig-1.模型结构 词表示层（word representation） 假设存在一个包含$n$个单词的句子$w_1 \\dots w_n$,我们首先通过$\\texttt{Adapter} \\circ \\texttt{BERT}$将其转换为矢量表征. $$ e_1 \\dots e_n = \\texttt{Adapter} \\circ \\texttt{BERT}(w_1 \\dots w_n) $$ 注意：值得注意的是，$\\texttt{Adapter} \\circ \\texttt{BERT}$方法不再需要对庞大的BERT参数进行微调，而是通过调整轻得多的适配器参数来获得相当的性能。因此通过这种方式，可以很容易地将词的表示法扩展为annotator-aware的表示法。 注释者切换器层（annotator switcher） 作者目标是有效地学习不同数据标注师意识到的词汇特征，这可以被视为对个别注释者的上下文理解。因此，引入了一个注释者切换器，以支持带有注释者输入的$\\texttt{Adapter} \\circ \\texttt{BERT}$，其灵感来自于Parameter Generation Network (PGN)，其关键思想是使用参数生成网络（PGN），通过输入annotators动态地产生适配器参数。通过这种方式，模型可以在不同的annotators之间灵活地切换。 具体来说，假设$V$是所有适配器参数的矢量形式，通过打包操作，也可以解包恢复所有的适配器参数，PGN模块就是根据annotators的输入动态生成$\\texttt{Adapter} \\circ \\texttt{BERT}$的$V$，如模型图中右边的橙色部分所示，切换器switcher可以被形式化为： $$ \\begin{align} \\textbf{x} \u0026=\\textbf{r}_1’ \\dots \\textbf{n}_1’\\\\ \u0026=\\textbf{PGN} \\circ \\textbf{Adapter} \\circ \\textbf{BERT}(x,a)\\\\ \u0026=\\textbf{Adapter} \\circ \\textbf{BERT}(x,\\textbf{V}=\\mathbf{\\Theta} \\times \\textbf{e}^a) \\end{align} $$ 其中$\\mathbf{\\Theta} \\in \\mathcal{R}^{\\vert \\textbf{V} \\vert \\times\\textbf{e}^a}$，$\\textbf{x} =\\textbf{r}_1’ \\dots \\textbf{n}_1’$是注释者$a$对$x=w_1 \\dots w_n$的annotator-aware的表示，$\\textbf{e}^a$是annotator的embedding。 BiLSTM编码层（BiLSTM Encoding） $\\texttt{Adapter} \\circ \\texttt{BERT}$需要一个额外的面向任务的模块来进行高级特征提取。在这里利用单一的BiLSTM层来实现：$h_1 \\dots h_n = \\texttt{BiLSTM}(x)$，用于下一步的推理和训练。 CRF层（CRF inference and training） 最后使用CRF来计算候选顺序输出$y = l_1 \\dots l_n$的全局得分。 $$ \\begin{align} {\\textbf{o}_i} \u0026=\\textbf{W}^{crf} {\\textbf{h}_i}+\\textbf{b}^{crf} \\ \\end{align} $$ $$ \\begin{align} {\\sum_{i=1}^n} (\\textbf{T}[l_{i-1},l_i]+{\\textbf{o}_i}[l_i]) \\end{align} $$ 其中$\\textbf{W}^{crf}、 \\textbf{b}^{crf}、 \\textbf{T}$是模型的参数。给定一个输入$(x，a)$，通过维特比算法进行推理,对于训练，定义了一个句子级别的交叉熵目标。 $$ \\begin{align} p(y^a \\vert x,a) \u0026=\\frac{\\exp{\\texttt{score}(y^a \\vert x,a)}}{\\sum_y \\exp{\\texttt{score}(y \\vert x,a)}}\\\\ \\mathcal{L} \u0026=-\\log{(y^a \\vert x,a)} \\end{align} $$ 其中$y^a$是$a$对$x$的黄金标准输出，$y$属于所有可能的候选人，$p(y^a|x, a)$表示句子级的概率。 ","date":"2022-03-03","objectID":"/paper01/:0:4","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#bilstm编码层bilstm-encoding"},{"categories":["documentation"],"content":"模型架构 包括四个部分： (1) word representation (2) annotator switcher (3) BiLSTM Encoding (4) CRF inference and training. Fig-1.模型结构 词表示层（word representation） 假设存在一个包含$n$个单词的句子$w_1 \\dots w_n$,我们首先通过$\\texttt{Adapter} \\circ \\texttt{BERT}$将其转换为矢量表征. $$ e_1 \\dots e_n = \\texttt{Adapter} \\circ \\texttt{BERT}(w_1 \\dots w_n) $$ 注意：值得注意的是，$\\texttt{Adapter} \\circ \\texttt{BERT}$方法不再需要对庞大的BERT参数进行微调，而是通过调整轻得多的适配器参数来获得相当的性能。因此通过这种方式，可以很容易地将词的表示法扩展为annotator-aware的表示法。 注释者切换器层（annotator switcher） 作者目标是有效地学习不同数据标注师意识到的词汇特征，这可以被视为对个别注释者的上下文理解。因此，引入了一个注释者切换器，以支持带有注释者输入的$\\texttt{Adapter} \\circ \\texttt{BERT}$，其灵感来自于Parameter Generation Network (PGN)，其关键思想是使用参数生成网络（PGN），通过输入annotators动态地产生适配器参数。通过这种方式，模型可以在不同的annotators之间灵活地切换。 具体来说，假设$V$是所有适配器参数的矢量形式，通过打包操作，也可以解包恢复所有的适配器参数，PGN模块就是根据annotators的输入动态生成$\\texttt{Adapter} \\circ \\texttt{BERT}$的$V$，如模型图中右边的橙色部分所示，切换器switcher可以被形式化为： $$ \\begin{align} \\textbf{x} \u0026=\\textbf{r}_1’ \\dots \\textbf{n}_1’\\\\ \u0026=\\textbf{PGN} \\circ \\textbf{Adapter} \\circ \\textbf{BERT}(x,a)\\\\ \u0026=\\textbf{Adapter} \\circ \\textbf{BERT}(x,\\textbf{V}=\\mathbf{\\Theta} \\times \\textbf{e}^a) \\end{align} $$ 其中$\\mathbf{\\Theta} \\in \\mathcal{R}^{\\vert \\textbf{V} \\vert \\times\\textbf{e}^a}$，$\\textbf{x} =\\textbf{r}_1’ \\dots \\textbf{n}_1’$是注释者$a$对$x=w_1 \\dots w_n$的annotator-aware的表示，$\\textbf{e}^a$是annotator的embedding。 BiLSTM编码层（BiLSTM Encoding） $\\texttt{Adapter} \\circ \\texttt{BERT}$需要一个额外的面向任务的模块来进行高级特征提取。在这里利用单一的BiLSTM层来实现：$h_1 \\dots h_n = \\texttt{BiLSTM}(x)$，用于下一步的推理和训练。 CRF层（CRF inference and training） 最后使用CRF来计算候选顺序输出$y = l_1 \\dots l_n$的全局得分。 $$ \\begin{align} {\\textbf{o}_i} \u0026=\\textbf{W}^{crf} {\\textbf{h}_i}+\\textbf{b}^{crf} \\ \\end{align} $$ $$ \\begin{align} {\\sum_{i=1}^n} (\\textbf{T}[l_{i-1},l_i]+{\\textbf{o}_i}[l_i]) \\end{align} $$ 其中$\\textbf{W}^{crf}、 \\textbf{b}^{crf}、 \\textbf{T}$是模型的参数。给定一个输入$(x，a)$，通过维特比算法进行推理,对于训练，定义了一个句子级别的交叉熵目标。 $$ \\begin{align} p(y^a \\vert x,a) \u0026=\\frac{\\exp{\\texttt{score}(y^a \\vert x,a)}}{\\sum_y \\exp{\\texttt{score}(y \\vert x,a)}}\\\\ \\mathcal{L} \u0026=-\\log{(y^a \\vert x,a)} \\end{align} $$ 其中$y^a$是$a$对$x$的黄金标准输出，$y$属于所有可能的候选人，$p(y^a|x, a)$表示句子级的概率。 ","date":"2022-03-03","objectID":"/paper01/:0:4","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#crf层crf-inference-and-training"},{"categories":["documentation"],"content":"代码解读 待复现 ","date":"2022-03-03","objectID":"/paper01/:0:5","series":null,"tags":["NER","NLP","Domain Adaptation"],"title":"ACl-2021-Crowdsourcing Learning as Domain Adaptation: A Case Study on Named Entity Recognition","uri":"/paper01/#代码解读"},{"categories":["documentation"],"content":"Begio经典论文’A Neural Probabilistic Language Model‘","date":"2022-03-01","objectID":"/nnlm/","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/"},{"categories":["documentation"],"content":"A Neural Probabilistic Language Model 这篇论文是预训练语言模型的开山之作，Yoshua Bengio等于2003年提出的方法。 ","date":"2022-03-01","objectID":"/nnlm/:1:0","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/#a-neural-probabilistic-language-model"},{"categories":["documentation"],"content":"观点 将词汇表$V$中的每个单词${w_i}$关联到一个分布式单词特征向量$\\mathcal{R}^m$。 将句子的联合概率函数表示为句子序列中单词特征向量的组合。 同时学习单词的特征向量和句子联合概率函数的参数。 ","date":"2022-03-01","objectID":"/nnlm/:1:1","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/#观点"},{"categories":["documentation"],"content":"模型 假设存在句子$w_1,\\dots，w_i,\\dots,w_n$，其中$w_n \\in V$，$V$表示词汇集合，$w_i$表示单词，目标函数是学习$f(w_t,\\dots,w_{t-n+1})=\\hat{P}(w_t \\vert w_1^{t-1})$的参数。 Bengio等人将模型分成两个部分： 一个映射函数$C$，将 $V$中的第$i$个单词$w_i$映射成为一个 特征向量 $C(w_i)\\in \\mathcal{R}^m$，它表示词汇表中与每个单词相关的分布特征向量。 一个使用映射函数$C$表示的概率函数$g$，通过上下文中单词的特征向量的乘积组成联合概率模型，$g$的输出是一个向量，它的第$i$个元素估计了概率。 $$ f(i,w_{t-1},\\dots,w_{t-n+1})=g(i,C(w_{t-1}),\\dots,C(w_{t-n+1})) $$ 函数$f$是这两个映射($C$和$g$)的组合，上下文中的所有单词都共享$C$。与这两个部分的每个部分关联一些参数。 数学符号说明： $C(i)$：单词$w$对应的词向量，其中$i$为词$w$在整个词汇表中的索引 $C$：词向量，大小为$\\vert V \\vert \\times m$的矩阵 $\\vert V \\vert$：词汇表的大小，即预料库中去重后的单词个数 $m$：词向量的维度，一般大于50 $H$：隐藏层的 weight $d$：隐藏层的 bias $U$：输出层的 weight $b$：输出层的 bias $W$：输入层到输出层的 weight $h$：隐藏层神经元个数 计算流程： 首先将输入的$n-1$个单词索引转为词向量，然后将这$n-1$个向量进行 concat，形成一个$(n-1)\\times w$ 的矩阵，用$X$表示 将$X$送入隐藏层进行计算，$\\textit{hidden}_\\text{out}=\\tanh{(d + X * H)}$ 输出层共有$\\vert V \\vert$个节点，每个节点$y_i$表示预测下一个单词$i$的概率， $y$的计算公式为$y=b+X*W+\\textit{hidden}_\\text{out} * U$ ","date":"2022-03-01","objectID":"/nnlm/:1:2","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/#模型"},{"categories":["documentation"],"content":"代码 # code by Tae Hwan Jung @graykode, modify by wmathor import torch import torch.nn as nn import torch.optim as optim import torch.utils.data as Data dtype = torch.FloatTensor sentences = [ \"i like dog\", \"i love coffee\", \"i hate milk\"] word_list = \" \".join(sentences).split() # ['i', 'like', 'dog', 'dog', 'i', 'love', 'coffee', 'i', 'hate', 'milk'] word_list = list(set(word_list)) # ['i', 'like', 'dog', 'love', 'coffee', 'hate', 'milk'] word_dict = {w: i for i, w in enumerate(word_list)} # {'i':0, 'like':1, 'dog':2, 'love':3, 'coffee':4, 'hate':5, 'milk':6} number_dict = {i: w for i, w in enumerate(word_list)} # {0:'i', 1:'like', 2:'dog', 3:'love', 4:'coffee', 5:'hate', 6:'milk'} n_class = len(word_dict) # number of Vocabulary, just like |V|, in this task n_class=7 # NNLM(Neural Network Language Model) Parameter n_step = len(sentences[0].split())-1 # n-1 in paper, look back n_step words and predict next word. In this task n_step=2 n_hidden = 2 # h in paper m = 2 # m in paper, word embedding dim def make_batch(sentences): input_batch = [] target_batch = [] for sen in sentences: word = sen.split() input = [word_dict[n] for n in word[:-1]] # [0, 1], [0, 3], [0, 5] target = word_dict[word[-1]] # 2, 4, 6 input_batch.append(input) # [[0, 1], [0, 3], [0, 5]] target_batch.append(target) # [2, 4, 6] return input_batch, target_batch input_batch, target_batch = make_batch(sentences) input_batch = torch.LongTensor(input_batch) target_batch = torch.LongTensor(target_batch) dataset = Data.TensorDataset(input_batch, target_batch) loader = Data.DataLoader(dataset=dataset, batch_size=16, shuffle=True) class NNLM(nn.Module): def __init__(self): super(NNLM, self).__init__() self.C = nn.Embedding(n_class, m) self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).type(dtype)) self.W = nn.Parameter(torch.randn(n_step * m, n_class).type(dtype)) self.d = nn.Parameter(torch.randn(n_hidden).type(dtype)) self.U = nn.Parameter(torch.randn(n_hidden, n_class).type(dtype)) self.b = nn.Parameter(torch.randn(n_class).type(dtype)) def forward(self, X): ''' X: [batch_size, n_step] ''' X = self.C(X) # [batch_size, n_step] =\u003e [batch_size, n_step, m] X = X.view(-1, n_step * m) # [batch_size, n_step * m] hidden_out = torch.tanh(self.d + torch.mm(X, self.H)) # [batch_size, n_hidden] output = self.b + torch.mm(X, self.W) + torch.mm(hidden_out, self.U) # [batch_size, n_class] return output model = NNLM() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=1e-3) # Training for epoch in range(5000): for batch_x, batch_y in loader: optimizer.zero_grad() output = model(batch_x) # output : [batch_size, n_class], batch_y : [batch_size] (LongTensor, not one-hot) loss = criterion(output, batch_y) if (epoch + 1)%1000 == 0: print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.6f}'.format(loss)) loss.backward() optimizer.step() # Predict predict = model(input_batch).data.max(1, keepdim=True)[1] # Test print([sen.split()[:n_step] for sen in sentences], '-\u003e', [number_dict[n.item()] for n in predict.squeeze()]) ","date":"2022-03-01","objectID":"/nnlm/:2:0","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/#代码"},{"categories":["documentation"],"content":"参考 A Neural Probabilistic Language Model NNLM 的 PyTorch 实现 nlp-tutorial ","date":"2022-03-01","objectID":"/nnlm/:3:0","series":null,"tags":["Model","NLP","经典论文研读系列"],"title":"01-NNLM(’A Neural Probabilistic Language Model‘) ","uri":"/nnlm/#参考"},{"categories":null,"content":"关于我 中国科学院大学计算机应用技术研究生一年级在读，主要研究方向是自然语言处理，欢迎邮件联系我进行交流👏🏻，特别欢迎carry我发论文！ ","date":"2022-02-28","objectID":"/about/:1:0","series":null,"tags":null,"title":"About","uri":"/about/#关于我"},{"categories":null,"content":"Tags 👨‍💻 程序猿 💻 技术极客，热爱关于计算机的一切 🤪 强迫症与拖延症患者 🤔 数码爱好者 🍎 全家桶拥有者(bushi) ","date":"2022-02-28","objectID":"/about/:2:0","series":null,"tags":null,"title":"About","uri":"/about/#tags"},{"categories":null,"content":"关于版权 本站所有的原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 ","date":"2022-02-28","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#关于版权"},{"categories":["documentation"],"content":"本教程希望为入门数据科学、DeepLearning的同学提供Numpy的基本操作指南。","date":"2022-02-28","objectID":"/numpyguidebook/","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/"},{"categories":["documentation"],"content":"本教程希望为入门数据科学、DeepLearning的同学提供Numpy的基本操作指南。 ","date":"2022-02-28","objectID":"/numpyguidebook/:0:0","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#"},{"categories":["documentation"],"content":"Numpy 入门指南 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:0","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#numpy-入门指南"},{"categories":["documentation"],"content":"array基本属性 Numpy的主要对象是同构多维数组。它是一个元素表，所有类型都相同，由非负整数元组构成索引。 Numpy的数组类被调用为ndarray。存在以下属性： ndarray.ndim：数组的轴（维度）的个数。 ndarray.shape：数组的维度。一个整数元组，表示每个维度中数组的大小。对于有n行和m列的矩阵，shape将是(n,m)，即shape元组长度就是rank或者维度的个数ndim。 ndarray.size：数组元素的总数。 ndarray.dtype： 一个描述数组中元素类型的对象 。 ndarray.itemsize：数组中每个元素的字节大小。例如，元素为 float64 类型的数组的 itemsize 为8（=64/8），而 complex32 类型的数组的 itemsize 为4（=32/8）。它等于 ndarray.dtype.itemsize 。 import numpy as np #如何将列表转化为矩阵 array=np.array([[1,2,3], [2,3,4]]) print(array) #查看维度ndim print('number of dim: ',array.ndim) ##output: number of dim: 2 #查看几行几列 print('shape: ',array.shape) ##output: shape: (2, 3) #查看元素个数 print('size: ',array.size) ##output: size: 6 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:1","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#array基本属性"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 \u003e\u003e\u003e a = np.array(1,2,3,4) # WRONG \u003e\u003e\u003e a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . \u003e\u003e\u003e np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . \u003e\u003e\u003e np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 \u003e\u003e\u003e np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 \u003e\u003e\u003e np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) \u003e\u003e\u003e np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): \u003e\u003e\u003e from numpy import pi \u003e\u003e\u003e np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) \u003e\u003e\u003e x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points \u003e\u003e\u003e f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#创建数组"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nparray"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npzeros"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npones"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npempty"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nparange"},{"categories":["documentation"],"content":"创建数组 np.array 使用array函数从python元组中创建数组, 默认情况下，创建的数组的dtype是 float64 类型的。 import numpy as np #创建一维数组，ndim=1 a=np.array([2,23,4],dtype=np.int32) print(a) ##output:[ 2 23 4] #创建二维数组 b = np.array([(1.5,2,3), (4,5,6)]) print(b) ##output: [[ 1.5 2. 3. ] ## [ 4. 5. 6. ]] 注意：常见错误是，调用array时候传入多个数字参数，而不提供单个数字的列表类型作为参数。 a = np.array(1,2,3,4) # WRONG a = np.array([1,2,3,4]) # RIGHT np.zeros 创建一个全为0的数组 . np.zeros( (3,4) ) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]]) np.ones 创建一个全为1的数组 . np.ones((2,3,4), dtype=np.int16) # dtype can also be specified array([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16) np.empty 创建一个数组，其初始内容是随机的，取决于内存的状态。 np.empty( (2,3) ) # uninitialized, output may vary array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) np.arange 该函数返回指定范围内数组而不是列表 。（注意是左包含即[start,stop) ） numpy.arange([start, ]stop, [step, ]dtype=None, *, like=None) 主要参数：start–开始；step–结束；step:步长 np.arange( 10, 30, 5 ) array([10, 15, 20, 25]) np.arange( 0, 2, 0.3 ) # it accepts float arguments array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) np.linspace 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,axis=0): from numpy import pi np.linspace( 0, 2, 9 )# 9 numbers from 0 to 2 array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) x = np.linspace( 0, 2*pi, 100 )# useful to evaluate function at lots of points f = np.sin(x) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:2","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nplinspace"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到\u003e、\u003c、==、\u003e=、 \u003c= 、!=，返回一个全为布尔值的数组 import numpy as np b=np.arange(4) ##output：[0 1 2 3] #快速查找符合要求的值,逻辑判断 print(b==3,'\\n') #output :[False False False True] print(b!=3,'\\n') #output：[ True True True False] 转秩 import numpy as np B=np.arange(14,2, -1).reshape((3,4)) # B :array([[14, 13, 12, 11], # [10, 9, 8, 7], # [ 6, 5, 4, 3]]) print(np.transpose(B)) #[[14 10 6] # [13 9 5] # [12 8 4] # [11 7 3]] print(B.T) #[[14 10 6] # [13 9 5] # [12 8 4] # [11 7 3]] np.sort 对矩阵中的所有值从大到小排序。 #排序函数，sort(),针对每一行进行从小到大排序操作 B=np.arange(14,2, -1).reshape((3,4)) # B :array([[14, 13, 12, 11], # [10, 9, 8, 7], # [ 6, 5, 4, 3]]) print(np.sort(B)) # B':array([[11,12,13,14], # [ 7, 8, 9,10], # [ 3, 4, 5, 6]]) np.clip clip函数，clip(Array,Array_min,Array_max)，Array指的是将要被执行用的矩阵，而后面的最小值最大值则用于让函数判断矩阵中元素是否有比最小值小的或者比最大值大的元素，并将这些指定的元素转换为最小值或者最大值。 import numpy as np A=np.arange(2,14).reshape((3,4)) print(np.clip(A,5,9)) np.argmin 查找矩阵中的最小值的索引值 np.argmax 查找矩阵中的最大值的索引值 import numpy as np A=np.arange(2,14).reshape((3,4)) #[[ 2 3 4 5] # [ 6 7 8 9] # [10 11 12 13]] #numpy基本运算 print(A) #求矩阵中最小元素 print('最小值的索引值',np.argmin(A)) ##最小值的索引值 0 #求矩阵中最大元素 print('最大值的索引值',np.argmax(A)) #最大值的索引值 11 np.mean 求矩阵所有值的均值,亦写成A.mean() 同np.average( ) np.average import numpy as np A=np.arange(2,14).reshape((3,4)) #求矩阵的均值 print('矩阵平均值表示之一',np.mean(A),'|',A.mean()) #矩阵平均值表示之一 7.5 | 7.5 print('矩阵平均值表示之二',np.average(A)) #矩阵平均值表示之二 7.5 np.cumsum import numpy as np A=np.arange(2,14).reshape((3,4)) #求矩阵n项累加 #eg: array([ [ 2, 3, 4, 5] # [ 6, 7, 8, 9] # [10,11,12,13] ]) # ---\u003e[2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], ---\u003e [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 \u003e\u003e\u003e b=np.array([2,4,6]) \u003e\u003e\u003e np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 \u003e\u003e\u003e c=np.array([4,9,16]) \u003e\u003e\u003e np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#数组基本运算"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#加减运算"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#点乘叉乘"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#乘方"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#逻辑运算"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#转秩"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npsort"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npclip"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npargmin"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npargmax"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npmean"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npaverage"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npcumsum"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npdiff"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npexp"},{"categories":["documentation"],"content":"数组基本运算 加减运算 import numpy as np #加减运算 a=np.array([10,20,30,40]) b=np.arange(4) print(a,b) ##[10 20 30 40] [0 1 2 3] c=a+b d=a-b print(c,d) ##[10 21 32 43] [10 19 28 37] 点乘、叉乘 import numpy as np a=np.array([10,20,30,40]) b=np.arange(4) #叉乘 c=a*b print(\"\\n叉乘运算:\",c) ##output:叉乘运算: [ 0 20 60 120] #点乘 aa=np.array([[1,1],[0,1]]) bb=np.arange(4).reshape((2,2)) c_dot=np.dot(aa,bb) c_dot_2=aa.dot(bb) print(\"\\n点乘运算之一:\",c_dot) ##点乘运算之一: [[2 4] ## [2 3]] print(\"\\n点乘运算之二:\",c_dot_2) ##点乘运算之二: [[2 4] ## [2 3]] 乘方 使用a**b表示a的b次方 import numpy as np b=np.arange(4) #乘方运算 f=b**2 print(\"\\n乘方运算:\",f) #output:[0 1 4 9] 逻辑运算 快速查找数组中符合条件的值，涉及到、=、 [2 5 9 14 20 27 35 44 54 65 77 90] print('矩阵前n项累加',np.cumsum(A)) np.diff import numpy as np A=np.arange(2,14).reshape((3,4)) #累差运算函数diff,计算的便是每一行中后一项与前一项之差. #eg: array([ [ 2, 3, 4, 5], array([[1,1,1], # [ 6, 7, 8, 9], --- [1,1,1], # [10,11,12,13] ]) [1,1,1]]) print(np.diff(A)) np.exp 求e的幂次方。 b=np.array([2,4,6]) np.exp(b) array([ 7.3890561 , 54.59815003, 403.42879349]) np.sqrt 开方函数 c=np.array([4,9,16]) np.sqrt(c) array([2., 3., 4.]) ","date":"2022-02-28","objectID":"/numpyguidebook/:1:3","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npsqrt"},{"categories":["documentation"],"content":"索引、切片和迭代 一维数组 一维的数组可以进行索引、切片和迭代操作。 \u003e\u003e\u003e import numpy as np \u003e\u003e\u003e a=np.arange(10)**3 \u003e\u003e\u003e a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32) \u003e\u003e\u003e a[2] #获取第二个值 8 \u003e\u003e\u003e a[2:5] #获取第二到第五个值，以数组形式返回 array([ 8, 27, 64], dtype=int32) \u003e\u003e\u003e a[:6:2]=-1000 #修改第零个、第二个、第六个值为-1000 \u003e\u003e\u003e a array([ -1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729], dtype=int32) \u003e\u003e\u003e a[ : :-1] #倒序a array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000], dtype=int32) \u003e\u003e\u003e for i in a: ... print(i**(1/3.)) ... nan 1.0 nan 3.0 nan 5.0 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 多维数组 多维数组的每一个轴都有一个索引，这些索引以逗号的形式分隔的元组给出： \u003e\u003e\u003e def f(x,y): ... return 5*x+y ... \u003e\u003e\u003e b=np.fromfunction(f,(5,4),dtype=int) \u003e\u003e\u003e b array([[ 0, 1, 2, 3], [ 5, 6, 7, 8], [10, 11, 12, 13], [15, 16, 17, 18], [20, 21, 22, 23]]) \u003e\u003e\u003e b[2,3] #第二行第三列的数字 13 \u003e\u003e\u003e b[0:5,1] #第0~5行第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) \u003e\u003e\u003e b[ : ,1] #第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) \u003e\u003e\u003e b[1:3,:] #第1~3行的数字，以数组形式返回 array([[ 5, 6, 7, 8], [10, 11, 12, 13]]) 对多维数组进行迭代（iterating）是相对于第一个轴完成的。 \u003e\u003e\u003e for row in b: ... print(row) ... [0 1 2 3] [5 6 7 8] [10 11 12 13] [15 16 17 18] [20 21 22 23] 迭代操作 如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代器 : \u003e\u003e\u003e for element in b.flat: ... print(element) ... 0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 20 21 22 23 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:4","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#索引切片和迭代"},{"categories":["documentation"],"content":"索引、切片和迭代 一维数组 一维的数组可以进行索引、切片和迭代操作。 import numpy as np a=np.arange(10)**3 a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32) a[2] #获取第二个值 8 a[2:5] #获取第二到第五个值，以数组形式返回 array([ 8, 27, 64], dtype=int32) a[:6:2]=-1000 #修改第零个、第二个、第六个值为-1000 a array([ -1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729], dtype=int32) a[ : :-1] #倒序a array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000], dtype=int32) for i in a: ... print(i**(1/3.)) ... nan 1.0 nan 3.0 nan 5.0 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 多维数组 多维数组的每一个轴都有一个索引，这些索引以逗号的形式分隔的元组给出： def f(x,y): ... return 5*x+y ... b=np.fromfunction(f,(5,4),dtype=int) b array([[ 0, 1, 2, 3], [ 5, 6, 7, 8], [10, 11, 12, 13], [15, 16, 17, 18], [20, 21, 22, 23]]) b[2,3] #第二行第三列的数字 13 b[0:5,1] #第0~5行第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[ : ,1] #第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[1:3,:] #第1~3行的数字，以数组形式返回 array([[ 5, 6, 7, 8], [10, 11, 12, 13]]) 对多维数组进行迭代（iterating）是相对于第一个轴完成的。 for row in b: ... print(row) ... [0 1 2 3] [5 6 7 8] [10 11 12 13] [15 16 17 18] [20 21 22 23] 迭代操作 如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代器 : for element in b.flat: ... print(element) ... 0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 20 21 22 23 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:4","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#一维数组"},{"categories":["documentation"],"content":"索引、切片和迭代 一维数组 一维的数组可以进行索引、切片和迭代操作。 import numpy as np a=np.arange(10)**3 a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32) a[2] #获取第二个值 8 a[2:5] #获取第二到第五个值，以数组形式返回 array([ 8, 27, 64], dtype=int32) a[:6:2]=-1000 #修改第零个、第二个、第六个值为-1000 a array([ -1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729], dtype=int32) a[ : :-1] #倒序a array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000], dtype=int32) for i in a: ... print(i**(1/3.)) ... nan 1.0 nan 3.0 nan 5.0 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 多维数组 多维数组的每一个轴都有一个索引，这些索引以逗号的形式分隔的元组给出： def f(x,y): ... return 5*x+y ... b=np.fromfunction(f,(5,4),dtype=int) b array([[ 0, 1, 2, 3], [ 5, 6, 7, 8], [10, 11, 12, 13], [15, 16, 17, 18], [20, 21, 22, 23]]) b[2,3] #第二行第三列的数字 13 b[0:5,1] #第0~5行第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[ : ,1] #第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[1:3,:] #第1~3行的数字，以数组形式返回 array([[ 5, 6, 7, 8], [10, 11, 12, 13]]) 对多维数组进行迭代（iterating）是相对于第一个轴完成的。 for row in b: ... print(row) ... [0 1 2 3] [5 6 7 8] [10 11 12 13] [15 16 17 18] [20 21 22 23] 迭代操作 如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代器 : for element in b.flat: ... print(element) ... 0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 20 21 22 23 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:4","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#多维数组"},{"categories":["documentation"],"content":"索引、切片和迭代 一维数组 一维的数组可以进行索引、切片和迭代操作。 import numpy as np a=np.arange(10)**3 a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32) a[2] #获取第二个值 8 a[2:5] #获取第二到第五个值，以数组形式返回 array([ 8, 27, 64], dtype=int32) a[:6:2]=-1000 #修改第零个、第二个、第六个值为-1000 a array([ -1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729], dtype=int32) a[ : :-1] #倒序a array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000], dtype=int32) for i in a: ... print(i**(1/3.)) ... nan 1.0 nan 3.0 nan 5.0 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 多维数组 多维数组的每一个轴都有一个索引，这些索引以逗号的形式分隔的元组给出： def f(x,y): ... return 5*x+y ... b=np.fromfunction(f,(5,4),dtype=int) b array([[ 0, 1, 2, 3], [ 5, 6, 7, 8], [10, 11, 12, 13], [15, 16, 17, 18], [20, 21, 22, 23]]) b[2,3] #第二行第三列的数字 13 b[0:5,1] #第0~5行第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[ : ,1] #第1列的数字，以数组形式返回 array([ 1, 6, 11, 16, 21]) b[1:3,:] #第1~3行的数字，以数组形式返回 array([[ 5, 6, 7, 8], [10, 11, 12, 13]]) 对多维数组进行迭代（iterating）是相对于第一个轴完成的。 for row in b: ... print(row) ... [0 1 2 3] [5 6 7 8] [10 11 12 13] [15 16 17 18] [20 21 22 23] 迭代操作 如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代器 : for element in b.flat: ... print(element) ... 0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 20 21 22 23 ","date":"2022-02-28","objectID":"/numpyguidebook/:1:4","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#迭代操作"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 \u003e\u003e\u003e a=np.floor(10*np.random.random((3,4))) \u003e\u003e\u003e a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) \u003e\u003e\u003e a.shape (3, 4) \u003e\u003e\u003e a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) \u003e\u003e\u003e a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 \u003e\u003e\u003e a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) \u003e\u003e\u003e a.T.shape (4, 3) array.reshape() 改变为任意形状 。 \u003e\u003e\u003e a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 \u003e\u003e\u003e a array([[0, 1], [2, 3], [4, 5]]) \u003e\u003e\u003e np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) \u003e\u003e\u003e a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 \u003e\u003e\u003e a=np.arange(12).reshape(3,4) \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) \u003e\u003e\u003e a.resize((2,6)) \u003e\u003e\u003e a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) \u003e\u003e\u003e a = np.array([[1, 2], [3, 4]]) \u003e\u003e\u003ea \u003e\u003e\u003earray([[1, 2], [3, 4]]) \u003e\u003e\u003e b = np.array([[5, 6]]) \u003e\u003e\u003e b array([[5, 6]]) \u003e\u003e\u003e np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) \u003e\u003e\u003e np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) \u003e\u003e\u003e np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 \u003e\u003e\u003e x = np.arange(16.0).reshape(4, 4) \u003e\u003e\u003e x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) \u003e\u003e\u003e np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 \u003e\u003e\u003e x = np.arange(16.0).reshape(4, 4) \u003e\u003e\u003e x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) \u003e\u003e\u003e np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 \u003e\u003e\u003e x = np.arange(8.0) \u003e\u003e\u003e np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#array形状操作"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#改变数组的形状"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#arrayravel"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#arrayt"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#arrayreshape"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#arrayresize-"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#堆叠数组"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npvstack"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nphstack"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npconcatenate"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#分割数组"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#numpysplit"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nphsplit"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#npvsplit"},{"categories":["documentation"],"content":"array形状操作 改变数组的形状 array.ravel() 化成1*n的矩阵。 a=np.floor(10*np.random.random((3,4))) a array([[9., 8., 7., 4.], [5., 3., 5., 9.], [9., 4., 0., 0.]]) a.shape (3, 4) a.ravel() array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) a.reshape(-1) array([9., 8., 7., 4., 5., 3., 5., 9., 9., 4., 0., 0.]) Ps: array.ravel()作用等同于array.reshape(-1) array.T 转置矩阵 。 a.T array([[9., 5., 9.], [8., 3., 4.], [7., 5., 0.], [4., 9., 0.]]) a.T.shape (4, 3) array.reshape() 改变为任意形状 。 a = np.arange(6).reshape((3, 2))#将1*6矩阵转为3*2矩阵 a array([[0, 1], [2, 3], [4, 5]]) np.reshape(a, (2, 3)) #将3*2矩阵转为2*3矩阵 array([[0, 1, 2], [3, 4, 5]]) a.reshape(2,-1) #reshape操作中将size指定为-1，则会自动计算其他的size大小： array([[0, 1, 2], [3, 4, 5]]) array.resize( ) 该方法会直接修改数组本身的shape和size。 a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) a.resize((2,6)) a array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) 堆叠数组 np.vstack 属于一种上下合并的情况。 import numpy as np #合并Array A=np.array([1,1,1]) B=np.array([2,2,2]) #vstack:属于一种上下合并 print(np.vstack((A,B))) #Vertical stack #output: [[1 1 1] # [2 2 2]] np.hstack 属于一种左右合并的情况 import numpy as np A=np.array([1,1,1]) B=np.array([2,2,2]) D=np.hstack((A,B)) print(D) #[1 1 1 2 2 2] E=np.hstack((B,A)) print(E) #[2 2 2 1 1 1] np.concatenate #针对多个矩阵或序列进行合并操作，借助 # np.concatenate((A,A,A,...),axis=0 或 1) a = np.array([[1, 2], [3, 4]]) a array([[1, 2], [3, 4]]) b = np.array([[5, 6]]) b array([[5, 6]]) np.concatenate((a, b), axis=0)#合并列 array([[1, 2], [3, 4], [5, 6]]) np.concatenate((a, b.T), axis=1) #合并行 array([[1, 2, 5], [3, 4, 6]]) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 分割数组 numpy.split import numpy as np A=np.arange(12).reshape((3,4)) print(A) #分割函数np.split(array,number of split row/column,axis= 0 or 1) print(np.split(A,2,axis=1))#把四列分成2块（2列一块） # [array([ [0, 1], # [4, 5], # [8, 9]]), array([[ 2, 3], # [ 6, 7], # [10, 11]])] #axis=0,表示按行分割；axis=1,表示按列分割 print(np.split(A,3,axis=0)) #把三行按行分成3块（一行一块） #[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])] np.hsplit 按列拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.hsplit(x, 2) [array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] np.vsplit 按行拆开数组。 x = np.arange(16.0).reshape(4, 4) x array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]) np.vsplit(x, 2) [array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])] np.array_split 将一个数组拆分为大小相等或近似相等的多个子数组。如果无法进行均等划分，则不会引发异常。 x = np.arange(8.0) np.array_split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])] ","date":"2022-02-28","objectID":"/numpyguidebook/:1:5","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#nparray_split"},{"categories":["documentation"],"content":"拷贝和深拷贝 当计算和操作数组时，有时会将数据复制到新数组中，有时则不会 。 存在以下3种情况： 完全不复制 简单分配不会复制数组对象或其数据。 import numpy as np a=np.arange(4) # =的赋值方式会带有关联性 b=a c=a d=b #改变a的第一个值，b、c、d的第一个值也会同时改变。 浅拷贝 不同的数组对象可以共享相同的数据。view方法创建一个查看相同数据的新数组对象。 \u003e\u003e\u003e import numpy as np \u003e\u003e\u003e a=np.arange(12).reshape(3,4) \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) \u003e\u003e\u003e c=a.view() \u003e\u003e\u003e c is a False \u003e\u003e\u003e c.base is a False \u003e\u003e\u003e c array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) \u003e\u003e\u003e c.shape = 2,6 \u003e\u003e\u003e c array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) \u003e\u003e\u003e a.shape (3, 4) \u003e\u003e\u003e c[0,4] = 1234 \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) \u003e\u003e\u003e c array([[ 0, 1, 2, 3, 1234, 5], [ 6, 7, 8, 9, 10, 11]]) 深拷贝copy() 该copy方法生成数组及其数据的完整副本。 import numpy as np a=np.arange(4) #copy()的赋值方式没有关联性 b=a.copy() print(b) a[3]=45 print('a:',a) #a: [11 1 2 45] print('b:',b) #b: [11 1 2 3] @all right save,ZhangGehang. ","date":"2022-02-28","objectID":"/numpyguidebook/:1:6","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#拷贝和深拷贝"},{"categories":["documentation"],"content":"拷贝和深拷贝 当计算和操作数组时，有时会将数据复制到新数组中，有时则不会 。 存在以下3种情况： 完全不复制 简单分配不会复制数组对象或其数据。 import numpy as np a=np.arange(4) # =的赋值方式会带有关联性 b=a c=a d=b #改变a的第一个值，b、c、d的第一个值也会同时改变。 浅拷贝 不同的数组对象可以共享相同的数据。view方法创建一个查看相同数据的新数组对象。 import numpy as np a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c=a.view() c is a False c.base is a False c array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c.shape = 2,6 c array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) a.shape (3, 4) c[0,4] = 1234 a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) c array([[ 0, 1, 2, 3, 1234, 5], [ 6, 7, 8, 9, 10, 11]]) 深拷贝copy() 该copy方法生成数组及其数据的完整副本。 import numpy as np a=np.arange(4) #copy()的赋值方式没有关联性 b=a.copy() print(b) a[3]=45 print('a:',a) #a: [11 1 2 45] print('b:',b) #b: [11 1 2 3] @all right save,ZhangGehang. ","date":"2022-02-28","objectID":"/numpyguidebook/:1:6","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#完全不复制"},{"categories":["documentation"],"content":"拷贝和深拷贝 当计算和操作数组时，有时会将数据复制到新数组中，有时则不会 。 存在以下3种情况： 完全不复制 简单分配不会复制数组对象或其数据。 import numpy as np a=np.arange(4) # =的赋值方式会带有关联性 b=a c=a d=b #改变a的第一个值，b、c、d的第一个值也会同时改变。 浅拷贝 不同的数组对象可以共享相同的数据。view方法创建一个查看相同数据的新数组对象。 import numpy as np a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c=a.view() c is a False c.base is a False c array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c.shape = 2,6 c array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) a.shape (3, 4) c[0,4] = 1234 a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) c array([[ 0, 1, 2, 3, 1234, 5], [ 6, 7, 8, 9, 10, 11]]) 深拷贝copy() 该copy方法生成数组及其数据的完整副本。 import numpy as np a=np.arange(4) #copy()的赋值方式没有关联性 b=a.copy() print(b) a[3]=45 print('a:',a) #a: [11 1 2 45] print('b:',b) #b: [11 1 2 3] @all right save,ZhangGehang. ","date":"2022-02-28","objectID":"/numpyguidebook/:1:6","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#浅拷贝"},{"categories":["documentation"],"content":"拷贝和深拷贝 当计算和操作数组时，有时会将数据复制到新数组中，有时则不会 。 存在以下3种情况： 完全不复制 简单分配不会复制数组对象或其数据。 import numpy as np a=np.arange(4) # =的赋值方式会带有关联性 b=a c=a d=b #改变a的第一个值，b、c、d的第一个值也会同时改变。 浅拷贝 不同的数组对象可以共享相同的数据。view方法创建一个查看相同数据的新数组对象。 import numpy as np a=np.arange(12).reshape(3,4) a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c=a.view() c is a False c.base is a False c array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) c.shape = 2,6 c array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) a.shape (3, 4) c[0,4] = 1234 a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) c array([[ 0, 1, 2, 3, 1234, 5], [ 6, 7, 8, 9, 10, 11]]) 深拷贝copy() 该copy方法生成数组及其数据的完整副本。 import numpy as np a=np.arange(4) #copy()的赋值方式没有关联性 b=a.copy() print(b) a[3]=45 print('a:',a) #a: [11 1 2 45] print('b:',b) #b: [11 1 2 3] @all right save,ZhangGehang. ","date":"2022-02-28","objectID":"/numpyguidebook/:1:6","series":null,"tags":["numpy","ML"],"title":"NumpyGuidebook","uri":"/numpyguidebook/#深拷贝copy"}]